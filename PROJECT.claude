# PROJECT.claude - Electron Development Directives

## ğŸ¯ Project Context
Building optimized Electron applications with voice-terminal hybrid capabilities, following VS Code-level optimization patterns discovered through comprehensive research.

## ğŸ“š Research Foundation
**Critical Documents** (Reference before ANY Electron work):
- `ELECTRON_INTEGRATED_KNOWLEDGE_FRAMEWORK.md` - Complete knowledge synthesis
- `ELECTRON_PERFORMANCE_OPTIMIZATION_GUIDE.md` - Performance techniques
- `ELECTRON_ARCHITECTURAL_PATTERNS.md` - Architecture patterns
- `ELECTRON_ECOSYSTEM_MAPPING.md` - Ecosystem insights

## âš¡ MANDATORY Pre-Implementation Checklist

### Before ANY Electron Feature:
```
â–¡ Process isolation strategy defined?
â–¡ IPC communication pattern selected (batched/streaming)?
â–¡ Memory management approach chosen?
â–¡ Security boundaries established?
â–¡ Performance budget allocated?
```

## ğŸ—ï¸ Architecture Directives

### 1. Process Architecture (ALWAYS)
```typescript
// MANDATORY: Multi-process separation
Main Process â†’ Coordination only
Renderer Process â†’ UI only (sandboxed)
Utility Process â†’ Extensions/heavy compute
Service Process â†’ Background tasks
```

### 2. IPC Communication (NEVER COMPROMISE)
```typescript
// ALWAYS: Batched async IPC
ipcRenderer.send('batch-operation', messages) âœ…

// NEVER: Synchronous IPC
ipcRenderer.sendSync('operation', data) âŒ // UI HANG!
```

### 3. Performance Patterns (NON-NEGOTIABLE)
- **Startup**: Implement V8 snapshots for <2s startup
- **Memory**: Stream processing for >10MB data
- **Rendering**: Virtual scrolling for >1000 items
- **Loading**: Lazy load non-critical modules

## ğŸš¨ Anti-Pattern Detection

**STOP IMMEDIATELY if you're about to:**
1. Use `require()` in renderer process without preload
2. Implement synchronous IPC for any reason
3. Load entire datasets into memory
4. Create monolithic single-process architecture
5. Skip context isolation in renderer

## ğŸ” Decision Gates

### Architecture Decision Required?
â†’ Consult: `ELECTRON_ARCHITECTURAL_PATTERNS.md#decision-framework`

### Performance Issue Detected?
â†’ Reference: `ELECTRON_PERFORMANCE_OPTIMIZATION_GUIDE.md#optimization-matrix`

### Adding New Feature?
â†’ Check: Process isolation impact, IPC overhead, memory implications

## ğŸ’¡ Quick Reference Patterns

### Problem â†’ Solution Map
- **Slow startup** â†’ V8 snapshots + lazy loading
- **Memory leak** â†’ Stream processing + proper cleanup
- **UI freezing** â†’ Move to utility process + async IPC
- **Extension crashes** â†’ Process isolation + sandboxing
- **Large files** â†’ Virtual scrolling + streaming

### Implementation Priorities
1. **Security First**: Context isolation, sandboxing
2. **Performance Second**: Measure â†’ optimize â†’ validate
3. **Features Third**: Only after 1 & 2 are solid

## ğŸ”„ Continuous Validation

### On Every Commit:
1. Check against ElectronAntiPatterns in memory
2. Validate performance metrics remain in budget
3. Ensure process isolation maintained
4. Verify IPC patterns are async

### Weekly Review:
- Update memory graph with new discoveries
- Document any anti-patterns encountered
- Add successful patterns to knowledge base

## ğŸ¯ Project-Specific Directives

### Voice-Terminal Integration
- Voice processing in isolated utility process
- Terminal operations in separate service process
- UI updates via batched IPC (50ms windows)
- Audio streaming with proper cleanup handlers

### Module Structure
```
electron-shell/
  â”œâ”€â”€ main/           # Main process only
  â”œâ”€â”€ renderer/       # Sandboxed UI only
  â”œâ”€â”€ preload/        # Context bridge
  â”œâ”€â”€ services/       # Utility processes
  â””â”€â”€ shared/         # Type definitions

modules/
  â”œâ”€â”€ voice-engine/   # Isolated voice processing
  â”œâ”€â”€ tmux-controller/# Terminal management
  â””â”€â”€ ai-processor/   # WebWorker/utility process
```

## ğŸ“ˆ Success Metrics
- Startup time: <2 seconds
- Memory usage: <200MB baseline
- IPC latency: <16ms (60fps)
- Crash rate: <0.1%
- Extension impact: <10% performance

## ğŸ§  Living Knowledge Integration

This project uses MCP memory (context: "alphanumeric") to maintain:
- Applied patterns and their outcomes
- Performance metrics over time
- Anti-patterns discovered
- Architecture decisions and rationale

**Query memory before major decisions:**
```javascript
aim_search_nodes({context: "alphanumeric", query: "[pattern/optimization]"})
```

---

**Remember**: Every Electron decision should reference our research. When in doubt, consult the framework documents. Performance and security are not optional - they're fundamental.