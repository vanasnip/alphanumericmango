# WebSocket-Aware Ingress Configuration
# Sticky sessions, load balancing, SSL termination
# Support for 1000+ concurrent WebSocket connections per backend
# Health-based routing and automatic failover

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: websocket-ingress
  namespace: voice-terminal
  annotations:
    # WebSocket support
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/websocket-services: "websocket-proxy"
    
    # Sticky sessions for WebSocket connections
    nginx.ingress.kubernetes.io/affinity: "cookie"
    nginx.ingress.kubernetes.io/affinity-mode: "persistent"
    nginx.ingress.kubernetes.io/session-cookie-name: "voice-terminal-session"
    nginx.ingress.kubernetes.io/session-cookie-expires: "86400"
    nginx.ingress.kubernetes.io/session-cookie-max-age: "86400"
    nginx.ingress.kubernetes.io/session-cookie-path: "/"
    nginx.ingress.kubernetes.io/session-cookie-change-on-failure: "true"
    
    # Load balancing configuration
    nginx.ingress.kubernetes.io/upstream-hash-by: "$request_uri"
    nginx.ingress.kubernetes.io/load-balance: "ewma"
    
    # SSL configuration
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    
    # Rate limiting
    nginx.ingress.kubernetes.io/rate-limit: "1000"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    nginx.ingress.kubernetes.io/rate-limit-connections: "100"
    
    # Circuit breaker
    nginx.ingress.kubernetes.io/proxy-next-upstream: "error timeout http_502 http_503 http_504"
    nginx.ingress.kubernetes.io/proxy-next-upstream-tries: "3"
    nginx.ingress.kubernetes.io/proxy-next-upstream-timeout: "30"
    
    # Performance optimizations
    nginx.ingress.kubernetes.io/proxy-buffering: "off"
    nginx.ingress.kubernetes.io/proxy-buffer-size: "64k"
    nginx.ingress.kubernetes.io/proxy-buffers-number: "8"
    nginx.ingress.kubernetes.io/client-max-body-size: "100m"
    
    # Health checks
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/health-check-path: "/health"
    nginx.ingress.kubernetes.io/health-check-interval: "10s"
    nginx.ingress.kubernetes.io/health-check-timeout: "5s"
    nginx.ingress.kubernetes.io/health-check-grace-period: "30s"
    
    # Custom nginx configuration
    nginx.ingress.kubernetes.io/configuration-snippet: |
      # WebSocket upgrade headers
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header Host $host;
      
      # Session persistence headers
      proxy_set_header X-Session-ID $cookie_voice_terminal_session;
      proxy_set_header X-Connection-ID $request_id;
      
      # Performance optimizations
      proxy_cache_bypass $http_upgrade;
      proxy_http_version 1.1;
      
      # Connection limits per IP
      limit_conn_zone $binary_remote_addr zone=websocket_conn:10m;
      limit_conn websocket_conn 50;
      
      # Request rate limiting
      limit_req_zone $binary_remote_addr zone=websocket_req:10m rate=100r/m;
      limit_req zone=websocket_req burst=200 nodelay;
      
    # Server-side configuration
    nginx.ingress.kubernetes.io/server-snippet: |
      # WebSocket connection upgrade map
      map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
      }
      
      # Geographic load balancing
      geo $geo_backend {
        default us-west;
        ~^10\.1\. us-east;
        ~^10\.2\. eu-west;
        ~^10\.3\. asia-pacific;
      }
      
      # Health check for upstream selection
      upstream websocket_healthy {
        least_conn;
        server websocket-proxy.voice-terminal.svc.cluster.local:8080 max_fails=3 fail_timeout=30s;
        keepalive 32;
      }

spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - voice-terminal.example.com
    - ws.voice-terminal.example.com
    secretName: voice-terminal-tls
  rules:
  - host: voice-terminal.example.com
    http:
      paths:
      # WebSocket endpoint
      - path: /ws
        pathType: Prefix
        backend:
          service:
            name: websocket-proxy
            port:
              number: 8080
      # API endpoints
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: websocket-proxy
            port:
              number: 8080
      # Health check endpoint
      - path: /health
        pathType: Exact
        backend:
          service:
            name: websocket-proxy
            port:
              number: 8080
      # Metrics endpoint (internal)
      - path: /metrics
        pathType: Exact
        backend:
          service:
            name: websocket-proxy
            port:
              number: 9090
  - host: ws.voice-terminal.example.com
    http:
      paths:
      # Dedicated WebSocket subdomain
      - path: /
        pathType: Prefix
        backend:
          service:
            name: websocket-proxy
            port:
              number: 8080

---
# NGINX ConfigMap for advanced WebSocket configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-websocket-config
  namespace: ingress-nginx
data:
  # Main nginx configuration optimizations
  main-snippet: |
    # Worker process optimizations
    worker_processes auto;
    worker_rlimit_nofile 65535;
    worker_connections 4096;
    
    # Event-driven architecture
    events {
      use epoll;
      multi_accept on;
      worker_connections 4096;
    }
    
  # HTTP block configuration
  http-snippet: |
    # Connection pooling for WebSockets
    upstream_keepalive_connections 32;
    upstream_keepalive_timeout 60s;
    upstream_keepalive_requests 100;
    
    # Timeouts for long-lived connections
    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;
    proxy_connect_timeout 60s;
    
    # Buffer optimizations
    proxy_buffering off;
    proxy_buffer_size 64k;
    proxy_buffers 8 64k;
    proxy_busy_buffers_size 128k;
    
    # WebSocket-specific settings
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;
    proxy_cache_bypass $http_upgrade;
    proxy_http_version 1.1;
    
    # Connection state tracking
    map $http_upgrade $connection_upgrade {
      default upgrade;
      '' close;
    }
    
    # Real IP configuration for load balancers
    set_real_ip_from 10.0.0.0/8;
    set_real_ip_from 172.16.0.0/12;
    set_real_ip_from 192.168.0.0/16;
    real_ip_header X-Forwarded-For;
    real_ip_recursive on;
    
    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=api:10m rate=100r/m;
    limit_req_zone $binary_remote_addr zone=websocket:10m rate=200r/m;
    limit_conn_zone $binary_remote_addr zone=perip:10m;
    limit_conn_zone $server_name zone=perserver:10m;
    
    # Logging format for WebSocket connections
    log_format websocket_log '$remote_addr - $remote_user [$time_local] '
                           '"$request" $status $body_bytes_sent '
                           '"$http_referer" "$http_user_agent" '
                           '"$http_upgrade" "$connection_upgrade" '
                           'rt=$request_time uct="$upstream_connect_time" '
                           'uht="$upstream_header_time" urt="$upstream_response_time"';

---
# Load Balancer Service for multi-zone deployment
apiVersion: v1
kind: Service
metadata:
  name: websocket-loadbalancer
  namespace: voice-terminal
  annotations:
    # Cloud provider specific annotations
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
    service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "3600"
    service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"
    
    # Health check configuration
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: "2"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: "3"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "5"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "10"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: "HTTP"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: "/health"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "8080"
    
    # Session stickiness
    service.beta.kubernetes.io/aws-load-balancer-attributes: "load_balancing.cross_zone.enabled=true,access_logs.s3.enabled=true,access_logs.s3.bucket=voice-terminal-logs"
    
spec:
  type: LoadBalancer
  loadBalancerClass: service.k8s.aws/nlb
  ports:
  - name: https
    port: 443
    targetPort: 8080
    protocol: TCP
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  selector:
    app: websocket-proxy
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 86400

---
# TCP Load Balancer for WebSocket connections
apiVersion: v1
kind: Service
metadata:
  name: websocket-tcp-lb
  namespace: voice-terminal
  annotations:
    metallb.universe.tf/loadBalancerIPs: "192.168.1.100"
    metallb.universe.tf/allow-shared-ip: "voice-terminal"
spec:
  type: LoadBalancer
  ports:
  - name: websocket
    port: 8080
    targetPort: 8080
    protocol: TCP
  - name: websocket-tls
    port: 8443
    targetPort: 8080
    protocol: TCP
  selector:
    app: websocket-proxy
  sessionAffinity: ClientIP

---
# Gateway API configuration for advanced traffic management
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: websocket-gateway
  namespace: voice-terminal
spec:
  gatewayClassName: istio
  listeners:
  - name: websocket-http
    hostname: "voice-terminal.example.com"
    port: 80
    protocol: HTTP
    allowedRoutes:
      namespaces:
        from: Same
  - name: websocket-https
    hostname: "voice-terminal.example.com"
    port: 443
    protocol: HTTPS
    tls:
      mode: Terminate
      certificateRefs:
      - name: voice-terminal-tls
    allowedRoutes:
      namespaces:
        from: Same

---
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: websocket-route
  namespace: voice-terminal
spec:
  parentRefs:
  - name: websocket-gateway
  hostnames:
  - "voice-terminal.example.com"
  rules:
  - matches:
    - path:
        type: PathPrefix
        value: /ws
    backendRefs:
    - name: websocket-proxy
      port: 8080
      weight: 100
    filters:
    - type: RequestHeaderModifier
      requestHeaderModifier:
        set:
        - name: X-Forwarded-Proto
          value: https
        - name: X-Real-IP
          value: "{remote_addr}"
  - matches:
    - path:
        type: PathPrefix
        value: /api
    backendRefs:
    - name: websocket-proxy
      port: 8080
      weight: 100

---
# EndpointSlice for manual load balancing control
apiVersion: discovery.k8s.io/v1
kind: EndpointSlice
metadata:
  name: websocket-proxy-manual
  namespace: voice-terminal
  labels:
    kubernetes.io/service-name: websocket-proxy
addressType: IPv4
ports:
- name: websocket
  appProtocol: http
  protocol: TCP
  port: 8080
endpoints:
- addresses:
  - "10.244.1.10"
  - "10.244.2.10"
  - "10.244.3.10"
  conditions:
    ready: true
    serving: true
    terminating: false
  zone: "us-west-2a"
- addresses:
  - "10.244.1.11"
  - "10.244.2.11"
  conditions:
    ready: true
    serving: true
    terminating: false
  zone: "us-west-2b"

---
# Network Policy for WebSocket traffic control
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: websocket-network-policy
  namespace: voice-terminal
spec:
  podSelector:
    matchLabels:
      app: websocket-proxy
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow ingress controller traffic
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  # Allow internal service communication
  - from:
    - podSelector:
        matchLabels:
          app: tmux-backend
    ports:
    - protocol: TCP
      port: 8080
  # Allow health checks
  - from: []
    ports:
    - protocol: TCP
      port: 8080
  egress:
  # Allow Redis communication
  - to:
    - podSelector:
        matchLabels:
          app: redis-cluster
    ports:
    - protocol: TCP
      port: 6379
  # Allow tmux backend communication
  - to:
    - podSelector:
        matchLabels:
          app: tmux-backend
    ports:
    - protocol: TCP
      port: 9090
  # Allow DNS resolution
  - to: []
    ports:
    - protocol: UDP
      port: 53